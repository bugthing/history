#!/usr/bin/env ruby

require_relative '../lib/application.rb'

module Application
  class Window

    def initialize
      Curses.init_screen
      Curses.curs_set 0 # invisible cursor
      Curses.noecho # don't echo keys entered

      width30 = Integer(Curses.cols * 0.3)
      width70 = Curses.cols - width30
      height =  Curses.lines - 4

      @win = Curses::Window.new(Curses.lines, Curses.cols, 0, 0)
      @win_left = win.subwin(height, width70, 0, 0)
      @win_right = win.subwin(height, width30, 0, width70)
      @win_bottom = win.subwin(4, Curses.cols, height, 0)

      win_left.box("|", "-")
      win_left.refresh

      win_right.box("|", "-")
      win_right.refresh

      win_bottom.box("|", "-")
      win_bottom.keypad true # translate function keys to Curses::Key constants
      win_bottom.nodelay = true # don't block waiting for keyboard input with getch
      win_bottom.refresh

      @lines = []
      @command = ''
    end

    attr_reader :win, :win_left, :win_right, :win_bottom

    def handle_keyboard_input
      e = win_bottom.getch
      case e
      when Curses::Key::ENTER, 'e'
        show_msg(@command)
        @command = ''
      when 'q'
        exit(0)
      when String
        @command << e
      end
    end

    def show_msg(msg)
      win_left.clear
      #win_left.box("|", "-")
      #win_left.setpos(1, 1)
      #@lines.each { |line| win_left << "#{line}\n" }
      win_left.addstr(msg)
      win_left.refresh
    end

    def show_event(event)
      #table = TTY::Table.new header: ['Name', 'When', 'Data'], rohws: events.to_a
      #win_right.clear
      #win_right.addstr(table.render(:ascii, width: win_right.maxx - 2, resize: true))
      #win_right.addstr("\nLast refresh: #{Time.now.strftime('%b %d %H:%M:%S')}")
      #win_right.refresh
    end

    def teardown
      Curses.close_screen
    end
  end
end

win = Application::Window.new

begin
  win.handle_keyboard_input
end while 1 == 1
win.teardown
