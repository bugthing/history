#!/usr/bin/env ruby

require_relative '../system/container'
require 'irb'
require 'curses'

module Application
  class Window

    Lines = Class.new(Array) do
      attr_reader :max_length
      def <<(item)
        shift if max_length && (length + 1) > max_length
        super(item)
      end
    end

    def initialize
      Curses.init_screen
      Curses.start_color
      Curses.cbreak
      Curses.curs_set 0
      Curses.noecho
      Curses.init_pair(Curses::COLOR_BLUE,Curses::COLOR_BLUE,Curses::COLOR_BLACK)
      Curses.init_pair(Curses::COLOR_GREEN,Curses::COLOR_GREEN,Curses::COLOR_BLACK)
      Curses.init_pair(Curses::COLOR_RED,Curses::COLOR_RED,Curses::COLOR_BLACK)

      @win = Curses::Window.new(Curses.lines, Curses.cols, 0, 0)
      @win_left = win.subwin(win_top_height, win_top_width70, 0, 0)
      @win_right = win.subwin(win_top_height, win_top_width30, 0, win_top_width70)
      @win_bottom = win.subwin(4, Curses.cols, win_top_height, 0)

      IRB.conf[:ECHO] = false
      IRB.setup(__FILE__, argv: [])
      workspace = IRB::WorkSpace.new(self)
      @repl = IRB::Irb.new(workspace)

      @lines_left = Lines.new
      @lines_right = Lines.new
      @command = ''
    end

    attr_reader :win, :win_left, :win_right, :win_bottom, :lines_left, :lines_right, :repl

    def win_top_width30
      Integer(Curses.cols * 0.6)
    end

    def win_top_width70
      Curses.cols - win_top_width30
    end

    def win_top_height
      Curses.lines - 4
    end

    def handle_keyboard_input
      e = win_bottom.getch
      #require 'pry'; binding.pry
      case e
      when 10
        execute_command
        @command = ''
      when 127
        @command.chop!
      else
        @command << e
      end
      show_bottom(@command)
    end

    def show_left(line)
      lines_left << line
      draw(win_left, lines_left, 0)
    end

    def show_right(line)
      lines_right << line
      draw(win_right, lines_right, win_top_width70)
    end

    def show_bottom(line)
      win_bottom.clear
      win_bottom.setpos(1, 2)
      win_bottom.addstr(line)
      win_bottom.box("|", "-")
      win_bottom.refresh
    end

    def teardown
      Curses.close_screen
      Kernel.exit(0)
    end

    private

    def execute_command
      teardown if @command == 'q'
      result = repl.context.evaluate(@command, 1)
      #show_left("#{@command} => #{result}")
      show_left([@command, ' => ', result])
    rescue => e
      show_left("#{@command} => ERR: #{e.inspect}")
    end

    def draw(window, lines, xaxis)
      window.clear
      lines.each_with_index do |line, idx|
        window.setpos((idx + 1), 2)

        line_part1, line_part2, line_part3 = *line

        window.attron(Curses.color_pair(Curses::COLOR_BLUE)|Curses::A_NORMAL) do
          window.addstr(line_part1.to_s)
        end
        window.addstr(line_part2.to_s)
        window.attron(Curses.color_pair(Curses::COLOR_GREEN)|Curses::A_NORMAL) do
          window.addstr(line_part3.to_s)
        end

      end
      window.box("|", "-")
      window.refresh
    end
  end
end

win = Application::Window.new
win.show_left("Commands and return values go here")
win.show_right("Events info goes here")
win.show_bottom('Commands appear here')
begin

  # show events
  App[:event_store].read.each do |e|
    win.show_right([e.class.name, " #{e.metadata[:timestamp]} ", e.data])
  end

  win.handle_keyboard_input
end while 1 == 1

win.teardown
